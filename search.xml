<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Git 同步 Fork 项目]]></title>
    <url>%2F2018%2F08%2F01%2Fsyncing-a-fork%2F</url>
    <content type="text"><![CDATA[Github 全球最大的同性交友网站，这里拥有最前沿的IT技术创新，拥有最流行的开源项目，等等…，总之这里是我的知识仓库，每天都会在上面寻找，学习知识 扯远了，本篇解决对于fork的项目，如何进行源项目的更新和同步问题 远程仓库 查看fork项目的远程仓库信息 123git remote -vorigin https://github.com/YOUR_USERNAME/YOUR_FORK.git (fetch)origin https://github.com/YOUR_USERNAME/YOUR_FORK.git (push) 设置源项目仓库地址 1git remote add upstream https://github.com/ORIGINAL_OWNER/ORIGINAL_REPOSITORY.git 检查远程地址信息 12345git remote -vorigin https://github.com/YOUR_USERNAME/YOUR_FORK.git (fetch)origin https://github.com/YOUR_USERNAME/YOUR_FORK.git (push)upstream https://github.com/ORIGINAL_OWNER/ORIGINAL_REPOSITORY.git (fetch)upstream https://github.com/ORIGINAL_OWNER/ORIGINAL_REPOSITORY.git (push) 同步源仓库信息 获取源仓库更新 1234567git fetch upstreamremote: Counting objects: 75, done.remote: Compressing objects: 100% (53/53), done.remote: Total 62 (delta 27), reused 44 (delta 9)Unpacking objects: 100% (62/62), done.From https://github.com/ORIGINAL_OWNER/ORIGINAL_REPOSITORY * [new branch] master -&gt; upstream/master 查看本地master分支 12git checkout masterSwitched to branch 'master' 合并源仓库更新到本地master分支 12345678git merge upstream/masterUpdating a422352..5fdff0fFast-forward README | 9 ------- README.md | 7 ++++++ 2 files changed, 7 insertions(+), 9 deletions(-) delete mode 100644 README create mode 100644 README.md 附录 同步你的 Fork 仓库 Configuring a remote for a fork Syncing a fork]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Syncing</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux 之 MySQL]]></title>
    <url>%2F2018%2F07%2F23%2Flinux-mysql%2F</url>
    <content type="text"><![CDATA[之前粗略的接触了Linux的基础使用和安装，这次准备在自购的服务器上跑些应用，纯属娱乐，废话不说，上来就先仍数据库。数据库常用的Oracle,MySQL,SQL Server,MongoDB等，排名不分先后，自己平时接触最多的也就是MySQL，MongoDB，好MySQL先来一份。 介绍MySQL是一个开源数据库管理系统，通常作为流行的LEMP（Linux，Nginx，MySQL / MariaDB，PHP / Python / Perl）堆栈的一部分安装。它使用关系数据库和SQL（结构化查询语言）来管理其数据。 CentOS 7更喜欢MariaDB，它是由原始MySQL开发人员管理的MySQL分支，旨在替代MySQL。如果你在CentOS 7上运行yum install mysql，那么安装的是MariaDB，而不是MySQL。 清单 OS: CentOS 7 DataBase：MySQL 8.0.11 安装123456789101112# 1. 获取官方yum源安装包 mysql80-community-release-el7-1.noarch.rpm 是根据官网提供的版本信息wget wget https://dev.mysql.com/get/`mysql80-community-release-el7-1.noarch.rpm`# 2. 安装rpm包rpm -ivh mysql80-community-release-el7-1.noarch.rpm# 3. 安装mysql-serveryum install -y mysql-server# 4. 启动mysqld服务systemctl start mysqld# 5. 查看是否成功启动ps aux|grep mysqld# 6. 设置mysqld服务开机自启动systemctl enable mysqld 配置由于MySQL从5.7开始不允许在首次安装后，使用空密码进行登录，系统会随机生成一个密码以供管理员首次登录使用，这个密码记录在/var/log/mysqld.log文件中 12345678# 1. 查看系统提供密码cat /var/log/mysqld.log|grep 'A temporary password'# 2. 使用获取到的密码登录MySQLmysql -u root -p# 3. 切换数据库use mysql;# 4. 修改root密码 your_password 替换成你自己的密码就可以了，这个密码是强密码，要求密码包含大小写字母、数字及标点符号，长度大于6alter user 'root'@'localhost' identified by 'your_password'; 链接自己平时习惯使用 Navicat 进行数据库操作，因此这里进行配置链接已在云端刚刚安装的MySQL服务 ERROR 1130按照上图图的配置信息链接MySQL，发现错误提示：ERROR 1130: Host &#39;xxx.xxx.xxx.xxx&#39; is not allowed to connect to this MySQL server 原因不允许从远程登陆MySQL服务，只能在localhost 解决方法1234567891011121314# 切换数据库use mysql;# 修改user 指定的host 为 %update user set host = '%' where user = 'root';# 成功修改+-----------+------------------+| host | user |+-----------+------------------+| % | root || localhost | mysql.infoschema || localhost | mysql.session || localhost | mysql.sys |+-----------+------------------+4 rows in set (0.00 sec) ERROR 2059继续重试链接，错误提示：ERROR 2059: Authentication plugin &#39;caching_sha2_password&#39; cannot be loaded:The specified module could not be found. 原因MySQL 8不支持动态修改密码验证方式 解决方法12345678# 停止mysqlsystemctl stop mysqld.service# my.cnf文件中默认有下面的语句，删除前面的#号即可，没有的话就把它添加到my.cnf中 ，默认路径`/etc/my.cnf`default-authentication-plugin=mysql_native_password# 切换数据库use mysql# 给指定用户设置密码，这里`%`是因为之前已经将远程没有特殊指定，用%代替了localhostALTER USER 'root'@'%' IDENTIFIED WITH mysql_native_password BY 'your_password'; 附录 安装过程Pdf How To Install MySQL on CentOS 7 ERROR 1130 ERROR 2059]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[藏经阁]]></title>
    <url>%2F2018%2F07%2F16%2Ftreasure%2F</url>
    <content type="text"><![CDATA[工欲善其事，必先利其器 记录汇总一些资源库 导航页Hi World创造师导航UI设计师导航Devdocs 开发者网站国际大厂Google DeveloperApple DeveloperMicrosoft DeveloperFacebook DeveloperTwitter DeveloperGithub DeveloperBaidu DeveloperAlibaba DeveloperTencent Developer 手机厂商Android DeveloperiOS DeveloperSamsung DeveloperHuawei DeveloperXiaoMi DeveloperHTC DeveloperFlyme DeveloperOppo DeveloperVivo DeveloperSmartisan Developer360 Developer 应用市场Google PlayApp StoreXiaoMi 应用市场Huawei 应用市场360 应用市场酷安市场应用宝 小程序PWA微信小程序支付宝小程序快应用 ROM与论坛LineageOSXDAMokeeMoDaCo机锋智友MiUi0pengApps DevToolsIDEJetbrains 全家桶Android StudioXcodeEclipseVisual Studio CodeSublimePostManXshell Xftp PluginAlibaba Java Coding GuidelinesAndroid ButterKnife ZeleznyAndroid Material Design Icon GeneratorAndroid Parcelable code generatorAndroid Postfix CompletionAndroid Resource Usage CountAndroid Studio PrettifyADB IdeaEventBus3 Intellij PluginGrepConsoleGsonFormatJetbrains PluginsJrebelignoreLayoutFormatterMarkdown NavigatorPlantUML integrationSQLScoutTranslation Managed codeGithubGitlabBitbucketGiteeCoding YunGoogle CloudMicrosoft AzureAmazon Web ServicesAliyunTencent CloudDiDi CloudMT CloudNetEase Cloud MirrorTsinghuaGradleFirfox]]></content>
      <categories>
        <category>Resources</category>
      </categories>
      <tags>
        <tag>DevTool</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hugo 初体验]]></title>
    <url>%2F2018%2F07%2F11%2Fhugo%2F</url>
    <content type="text"><![CDATA[个人博客使用Hexo搭建，使用效果很不错，在Github上创建组织RootCluster，该组织主要存放自己新技术的学习和一些Demo实验。组织同样也可以使用Github pages服务，因此给RootCluster构建一个静态页面，可用直观清晰的看自己的项目，加之之前已用Hexo，所以这次的静态页面构建选择了新的一个静态页面生成工具，Hugo是一款使用Go语言开发的静态页面生成框架。 Hugo是世界上最快的静态网站引擎。它是用Go（aka Golang）编写的，由bep，spf13和朋友开发 材料准备 SystemOS：Windows 10 Chocolatey：Windows的包管理器 Hugo 安装Chocolatey安装如果已安装，跳过该步骤 使用 PowerShell.exe 1Set-ExecutionPolicy Bypass -Scope Process -Force; iex ((New-Object System.Net.WebClient).DownloadString('https://chocolatey.org/install.ps1')) 使用 cmd.exe 1@"%SystemRoot%\System32\WindowsPowerShell\v1.0\powershell.exe" -NoProfile -InputFormat None -ExecutionPolicy Bypass -Command "iex ((New-Object System.Net.WebClient).DownloadString('https://chocolatey.org/install.ps1'))" &amp;&amp; SET "PATH=%PATH%;%ALLUSERSPROFILE%\chocolatey\bin" 以上两种方式，选择其一即可 hugo安装1choco install hugo -confirm 初始化Hugo 初始化hugo模板 1hugo new site project_name 进入项目并启动项目 12cd project_name hugo serve 主题安装 这里选择Elate主题作为组织的网站]]></content>
      <categories>
        <category>Hugo</category>
      </categories>
      <tags>
        <tag>Build</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[非对称加密——RSA]]></title>
    <url>%2F2018%2F07%2F03%2Fsecurity-rsa%2F</url>
    <content type="text"><![CDATA[这是常用加密技术的系列文章，主要包含非对称，对称，JWT三类常用技术的应用 RSARSA：RSA加密算法是一种 非对称 加密算法。在公开密钥加密和电子商业中RSA被广泛使用。RSA是1977年由罗纳德·李维斯特（Ron Rivest）、阿迪·萨莫尔（Adi Shamir）和伦纳德·阿德曼（Leonard Adleman）一起提出的。RSA就是他们三人姓氏开头字母拼在一起组成的。 RSA加密解密公钥 加密 私钥 解密，持有公钥（多人持有）可以对数据加密，但是只有持有私钥（一人持有）才可以解密并查看数据 RSA加签验签私钥 加签 公钥 验签，持有私钥（一人持有）可以加签，持有公钥（多人持有）可以验签 RSA过程示意图 如上图，具体表述两个场景过程 结果不需加密场景：返回的数据不需要加密(例如：绑定银行卡的时候) 客户端Client A发送使用服务端Serve publicKey 加密 的密文cipher A(包含用户的银行卡号，手机号等重要信息)到服务器 服务器Serve 通过 Serve privateKey解密 服务端业务处理完成，直接返回数据(一些普通信息，比如状态码code，提示信息msg，提示操作是成功还是失败)给客户端Client A 结果需加密场景：返回的数据需要加密(例如：用户登录) 客户端Client B发送使用服务端Serve publicKey 加密 的密文cipher B(包含用户名和密码等重要信息)以及客户端Client B的Client B publicKey到服务器 服务器Serve 通过 Serve privateKey解密 服务端业务处理完成，直接返回数据(一般为token，token使用客户端Client B的Client B publicKey加密)给客户端Client B 客户端Client B使用Client B privateKey进行 解密 获取相应的用户信息等 密钥对在使用RSA加密解密之前，首先要生成密钥对。所谓的密钥对，指的是公钥和私钥。RSA算法的密钥可以通过两个途径生成，一是借助openssl命令终端，二是使用JDK生成。本篇采用JDK方式生成密钥对，openssl方式可自行尝试 JDKServe端密钥对Client端密钥对Android密钥对Web密钥对iOS密钥对OpenSSL略… RSA加密RSA解密RSA缺点虽然RSA是一种较高级别加密机制，但也存在一些缺点 产生密钥很麻烦，受到素数产生技术的限制，因而难以做到一次一密。 安全性，RSA的安全性依赖于大数的因子分解，但并没有从理论上证明破译RSA的难度与大数分解难度等价，而且密码学界多数人士倾向于因子分解不是NP问题。 速度太慢，由于RSA的分组长度太大，为保证安全性，n 至少也要 600 bit 以上，使运算代价很高，尤其是速度较慢，较对称密码算法慢几个数量级；且随着大数分解技术的发展，这个长度还在增加，不利于数据格式的标准化。 附录参考学习文章 一张图了解RSA加解密与加验签 RSA加密解密及RSA加签验签 RSA加解密和加签验签 RSA加密解密样例 RSA加密解密实现]]></content>
      <categories>
        <category>Security</category>
      </categories>
      <tags>
        <tag>RSA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Network（一） 之OkHttp 入门]]></title>
    <url>%2F2018%2F06%2F23%2Fnetwork-okhttp1%2F</url>
    <content type="text"><![CDATA[自从Android4.4的源码中可以看到HttpURLConnection已经替换成OkHttp开始( JakeWharton曾在Twitter表示 ) ，OkHttp+Retrofit+RxJava的组合网络请求一直经久不衰，主流app的网络架构基本都是这样的组合模式，存在即合理，说明OkHttp+Retrofit+RxJava的方式确实给开发，用户体验等带来可观的优势，那么这个系列文章围绕Android的网络展开. OkHttp：An HTTP &amp; HTTP/2 client for Android and Java applications Android 历史网络库 HttpClient 是 Apache 提供的HTTP网络访问接口，从一开始的时候就被引入到了Android的API中； HttpURLConnection 是一种多用途, 轻量极的HTTP客户端, 提供的API比较简单, 可以容易地去使用和扩展. OkHttp优势 支持HTTP/2, HTTP/2通过使用多路复用技术在一个单独的TCP连接上支持并发, 通过在一个连接上一次性发送多个请求来发送或接收数据 如果HTTP/2不可用, 连接池复用技术也可以极大减少延时 支持GZIP, 可以压缩下载体积 响应缓存可以直接避免重复请求 会从很多常用的连接问题中自动恢复 如果您的服务器配置了多个IP地址, 当第一个IP连接失败的时候, OkHttp会自动尝试下一个IP OkHttp还处理了代理服务器问题和SSL握手失败问题，等等… 基本使用该系列版本说明 OkHttp版本统一：3.10.0 JDK：1.8+ Gradle包导入1234// okhttp核心库implementation 'com.squareup.okhttp3:okhttp:3.10.0'// okhttp网络请求拦截日志库implementation 'com.squareup.okhttp3:logging-interceptor:3.10.0' OkHttp请求已在Http VS Https文章中介绍了，HTTP请求相关内容 OkHttp响应已在Http VS Https文章中介绍了，HTTP响应相关内容 同步与异步同步和异步关注的是消息通信机制 (synchronous communication/ asynchronous communication) 同步就是在发出一个 调用 时，在没有得到结果之前，该 调用 就不返回，但是一旦调用返回，就得到返回值了。换句话说，就是由 调用者 主动等待这个 调用 的结果。Okhttp同步(execute())：Invokes the request immediately, and blocks until the response can be processed or is in error. 123456789101112OkHttpClient client = new OkHttpClient(); String run(String url) throws IOException &#123; Request request = new Request.Builder().url(url).build(); // 执行同步操作 Response response = client.newCall(request).execute(); if (response.isSuccessful()) &#123; return response.body().string(); &#125; else &#123; throw new IOException("Unexpected code " + response); &#125;&#125; 异步异步 则与同步相反，调用 在发出之后，这个调用就直接返回了，所以没有返回结果。换句话说，当一个异步过程调用发出后，调用者 不会立刻得到结果。而是在 调用 发出后，被调用者 通过状态、通知来通知 调用者，或通过回调函数处理这个调用。Okhttp同步(enqueue(Callback responseCallback))：Schedules the request to be executed at some point in the future. 123456789101112131415161718192021String url = "https://api.github.com/users/BladeCode";OkHttpClient client = new OkHttpClient();Request request = new Request.Builder().url(url).build();// 返回response 对象Response response = client.newCall(request).enqueue(new Callback() &#123; @Override public void onFailure(Call call, IOException e) &#123; System.out.println(e.toString()); &#125; @Override public void onResponse(Call call, Response response) throws IOException &#123; // 字符串形式表达响应 System.out.println(response.body().string()); // 或流的形式表达响应 System.out.println(response.body().charStream()); System.out.println(response.body().byteStream()); &#125;&#125;); 注意： 响应体太大（超过1MB）, 应避免使用 string()方法, 因为它会将把整个文档加载到内存中. 对于超过1MB的响应body, 应使用流的方式来处理响应body. 这和我们处理xml文档的逻辑是一致的, 小文件可以载入内存树状解析, 大文件就必须流式解析 OkHttp Get123456789101112OkHttpClient client = new OkHttpClient(); String run(String url) throws IOException &#123; Request request = new Request.Builder().url(url).build(); Response response = client.newCall(request).execute(); if (response.isSuccessful()) &#123; return response.body().string(); &#125; else &#123; throw new IOException("Unexpected code " + response); &#125;&#125; OkHttp Post1234567891011121314151617181920public static final MediaType JSON = MediaType.parse("application/json; charset=utf-8");OkHttpClient client = new OkHttpClient();String post(String url, String json) throws IOException &#123; RequestBody body = RequestBody.create(JSON, json); Request request = new Request.Builder() .url(url) .post(body) .build(); Response response = client.newCall(request).execute(); if (response.isSuccessful()) &#123; return response.body().string(); &#125; else &#123; throw new IOException("Unexpected code " + response); &#125;&#125; 提交String1234567891011121314151617181920212223public static final MediaType MEDIA_TYPE_MARKDOWN = MediaType.parse("text/x-markdown; charset=utf-8"); private final OkHttpClient client = new OkHttpClient(); public void run() throws Exception &#123; String postBody = "" + "Releases\n" + "--------\n" + "\n" + " * _1.0_ May 6, 2013\n" + " * _1.1_ June 15, 2013\n" + " * _1.2_ August 11, 2013\n"; Request request = new Request.Builder() .url("https://api.github.com/markdown/raw") .post(RequestBody.create(MEDIA_TYPE_MARKDOWN, postBody)) .build(); Response response = client.newCall(request).execute(); if (!response.isSuccessful()) throw new IOException("Unexpected code " + response); System.out.println(response.body().string());&#125; 注意：当提交数据大于1MB，请使用流的方式 提交流123456789101112131415161718192021222324252627282930313233343536373839public static final MediaType MEDIA_TYPE_MARKDOWN = MediaType.parse("text/x-markdown; charset=utf-8"); private final OkHttpClient client = new OkHttpClient(); public void run() throws Exception &#123; RequestBody requestBody = new RequestBody() &#123; @Override public MediaType contentType() &#123; return MEDIA_TYPE_MARKDOWN; &#125; @Override public void writeTo(BufferedSink sink) throws IOException &#123; sink.writeUtf8("Numbers\n"); sink.writeUtf8("-------\n"); for (int i = 2; i &lt;= 997; i++) &#123; sink.writeUtf8(String.format(" * %s = %s\n", i, factor(i))); &#125; &#125; private String factor(int n) &#123; for (int i = 2; i &lt; n; i++) &#123; int x = n / i; if (x * i == n) return factor(x) + " × " + i; &#125; return Integer.toString(n); &#125; &#125;; Request request = new Request.Builder() .url("https://api.github.com/markdown/raw") .post(requestBody) .build(); Response response = client.newCall(request).execute(); if (!response.isSuccessful()) throw new IOException("Unexpected code " + response); System.out.println(response.body().string());&#125; 提交文件1234567891011121314151617public static final MediaType MEDIA_TYPE_MARKDOWN = MediaType.parse("text/x-markdown; charset=utf-8"); private final OkHttpClient client = new OkHttpClient(); public void run() throws Exception &#123; File file = new File("README.md"); Request request = new Request.Builder() .url("https://api.github.com/BladeCode/raw") .post(RequestBody.create(MEDIA_TYPE_MARKDOWN, file)) .build(); Response response = client.newCall(request).execute(); if (!response.isSuccessful()) throw new IOException("Unexpected code " + response); System.out.println(response.body().string());&#125; 提交表单使用FormEncodingBuilder来构建和HTML标签相同效果的请求体。键值对将使用一种HTML兼容形式的URL编码来进行编码 12345678910111213141516private final OkHttpClient client = new OkHttpClient(); public void run() throws Exception &#123; RequestBody formBody = new FormEncodingBuilder() .add("search", "Jurassic Park") .build(); Request request = new Request.Builder() .url("https://en.wikipedia.org/w/index.php") .post(formBody) .build(); Response response = client.newCall(request).execute(); if (!response.isSuccessful()) throw new IOException("Unexpected code " + response); System.out.println(response.body().string());&#125; 提交分块请求MultipartBuilder可以构建复杂的请求体，与HTML文件上传形式兼容。多块请求体中每块请求都是一个请求体，可以定义自己的请求头。这些请求头可以用来描述这块请求，例如他的Content-Disposition。如果Content-Length和Content-Type可用的话，他们会被自动添加到请求头中。 12345678910111213141516171819202122232425262728private static final String IMGUR_CLIENT_ID = "...";private static final MediaType MEDIA_TYPE_PNG = MediaType.parse("image/png");private final OkHttpClient client = new OkHttpClient();public void run() throws Exception &#123; // Use the imgur image upload API as documented at https://api.imgur.com/endpoints/image RequestBody requestBody = new MultipartBuilder() .type(MultipartBuilder.FORM) .addPart( Headers.of("Content-Disposition", "form-data; name=\"title\""), RequestBody.create(null, "Square Logo")) .addPart( Headers.of("Content-Disposition", "form-data; name=\"image\""), RequestBody.create(MEDIA_TYPE_PNG, new File("website/static/logo-square.png"))) .build(); Request request = new Request.Builder() .header("Authorization", "Client-ID " + IMGUR_CLIENT_ID) .url("https://api.imgur.com/3/image") .post(requestBody) .build(); Response response = client.newCall(request).execute(); if (!response.isSuccessful()) throw new IOException("Unexpected code " + response); System.out.println(response.body().string());&#125; 附录 怎样理解阻塞非阻塞与同步异步的区别 OkHttp使用教程]]></content>
      <categories>
        <category>Network</category>
      </categories>
      <tags>
        <tag>OkHttp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Http VS Https]]></title>
    <url>%2F2018%2F06%2F22%2Fnetwork-http%2F</url>
    <content type="text"><![CDATA[基础名称请求报文客户端发送一个HTTP请求到服务器的请求消息包括以下格式：请求行（request line）、请求头（header）、请求内容组成，如下请求报文的一般格式。 请求行 方法： GET： 获取资源 POST： 向服务器端发送数据，传输实体主体 PUT： 传输文件 HEAD： 获取报文首部 DELETE： 删除文件 OPTIONS： 询问支持的方法 TRACE： 追踪路径 URL： scheme://host:port/path?query scheme: 表示协议，如Http, Https, Ftp等 host: 表示所访问资源所在的主机名：如：www.baidu.com port: 表示端口号，Http默认为80,Https默认为443 path: 表示所访问的资源在目标主机上的储存路径 query: 表示查询条件 协议/版本号： 请求头 通用首部(General Header) 请求首部(Request Header) 实体首部(Entity Header Fields) 请求内容如: 客户端POST的数据就放在这里(对比:GET的数据放在请求行的URL里) 例如： 响应报文服务端响应一个HTTP请求消息包括以下格式：响应行（response line）、响应头（header）、响应内容组成 响应行 状态码： 1XX：Informational(信息性状态码) 2XX：Success(成功状态码) 3XX：Redirection(重定向) 4XX：Client Error(客户端错误状态码) 5XX：Server Error(服务器错误状态吗) 状态码描述： 协议/版本号： 响应头 通用首部(General Header) 响应首部(Response Header) 实体首部(Entity Header Fields) 响应内容如：服务器返回的HTML、JSON等数据 Http概念 HTTP：超文本传输协议（HyperText Transfer Protocol）是一种用于分布式、协作式和超媒体信息系统的应用层协议. HTTP是万维网的数据通信的基础. 通信 建立TCP连接在HTTP工作开始之前，Client首先要通过网络与Service建立连接，该连接是通过TCP来完成的，HTTP是比TCP更高层次的应用层协议，根据规则，只有低层协议建立之后才能进行更高层协议的连接，因此，首先要建立TCP连接 Client发起HTTP请求(Request)Requset通常包含请求行，请求头，请求内容这三部风组成的请求报文 Service发送HTTP响应(Response)Response通常包含响应行，响应头，响应内容这三部风组成的响应报文 Client关闭TCP连接 特点 无状态 每个请求结束后都会被关闭，每次的请求都是独立的，它的执行情况和结果与前面的请求和之后的请求是无直接关系的，它不会受前面的请求应答情况直接影响，也不会直接影响后面的请求应答情况 服务器中没有保存客户端的状态，客户端必须每次带上自己的状态去请求服务器 明文传输，可能被窃听 不验证通信方的身份，可能遭遇伪装 HTTP 协议中的请求和响应不会对通信方进行确认。也就是说存在“服务器是否就是发送请求中 URI 真正指定的主机，返回的响应是否真的返回到实际提出请求的客户端”等类似问题 HTTP 协议通信时，由于不存在确认通信方的处理步骤，任何人都可以发起请求 无法证明报文的完整性，可能遭遇篡改 在请求或响应送出之后直到对方接收之前的这段时间内，即使请求或响应的内容遭到篡改，也没有办法获悉 Https概念 HTTPS：超文本传输安全协议（Hypertext Transfer Protocol Secure，常称为HTTP over TLS，HTTP over SSL或HTTP Secure）是一种通过计算机网络进行安全通信的传输协议. HTTPS经由HTTP进行通信，但利用SSL/TLS来加密数据包. HTTP+加密+认证+完整性保护 = HTTPS 通信SSL/TLSSSL/TLS：安全传输层协议(Transport Layer Security), 是介于TCP和HTTP之间的一层安全协议，TLS的前身是SSL(Secure Sockets Layer) TLS/SSL关系 SSL2.0 SSL3.0 TLS1.0(SSL3.1) TLS1.1(SSL3.2) TLS1.2(SSL3.3) SSL/TLS工作原理HTTPS协议的主要功能都依赖于SSL/TLS协议，SSL/TLS的功能实现主要依赖于三类算法：对称加密,非对称加密,散列函数Hash 非对称加密实现身份认证和密钥协商， 对称加密算法采用协商的密钥对数据加密， 基于散列函数验证信息的完整性 SSL/TLS协议实现TLS以记录协议(record protocol)实现。记录协议负责在传输连接上交换所有的底层消息，并可以配置加密。每一条TLS记录以一个短标头起始。标头包含记录内容的类型(或子协议)、协议版本和长度 TLS的主规格说明书定义了四个核心子协议： 握手协议(handshake protocol)； 密钥规格变更协议(change cipher spec protocol)； 应用数据协议(application data protocol)； 警报协议(alert protocol)； 握手协议握手是TLS协议中最精密复杂的部分。在这个过程中，通信双方协商连接参数，并且完成身份验证。根据使用的功能的不同，整个过程通常需要交换6~10条消息。根据配置和支持的协议扩展的不同，交换过程可能有许多变种，在使用中经常可以观察到以下三种流程： 单向验证(完整的握手，对服务器进行身份验证) 双向验证(对客户端和服务器都进行身份验证的握手) 简短握手(恢复之前的会话) 单向验证 Handshake:ClentHello客户端通过发送 Client Hello 报文开始 SSL通信。报文中包含客户端支持的 SSL的指定版本、加密组件（Cipher Suite）列表（所使用的加密算法及密钥长度等）。 Handshake:ServerHello服务器可进行 SSL通信时，会以 ServerHello 报文作为应答。和客户端一样，在报文中包含 SSL版本以及加密组件。服务器的加密组件内容是从接收到的客户端加密组件内筛选出来的。 Handshake:Certificate之后服务器发送 Certificate 报文。报文中包含公开密钥证书。 Handshake:ServerHelloDone最后服务器发送 ServerHelloDone 报文通知客户端，最初阶段的 SSL握手协商部分结束。 Handshake:ClientKeyExchangeSSL第一次握手结束之后，客户端以 ClientKeyExchange 报文作为回应。报文中包含通信加密中使用的一种被称为 Pre-mastersecret 的随机密码串。该报文已用3 中的公开密钥进行加密。 ChangeCipherSpec接着客户端继续发送 ChangeCipherSpec 报文。该报文会提示服务器，在此报文之后的通信会采用 Pre-master secret 密钥加密。 Handshake:Finished客户端发送 Finished 报文。该报文包含连接至今全部报文的整体校验值。这次握手协商是否能够成功，要以服务器是否能够正确解密该报文作为判定标准。 ChangeCipherSpec服务器同样发送 ChangeCipherSpec 报文。 Handshake:Finished服务器同样发送 Finished 报文。 Application Data(HTTP)服务器和客户端的 Finished 报文交换完毕之后，SSL连接就算建立完成。当然，通信会受到 SSL的保护。从此处开始进行应用层协议的通信，即发送 HTTP 请求。 Application Data(HTTP)应用层协议通信，即发送 HTTP 响应。 Alert:warning,close notify最后由客户端断开连接。断开连接时，发送 close_notify 报文(上图做了一些省略，实际到这一步还需要发送TCP FIN报文关闭TCP链接) 双向验证同单向验证流程相比，双向验证多了如下两条消息：CertificateRequest与CertificateVerify，其余流程大致相同 CertificateRequestCertificateRequest是TLS规定的一个可选功能，用于服务器认证客户端的身份。通过服务器要求客户端发送一个证书实现，服务器应该在ServerKeyExchange之后立即发送CertificateRequest消息 CertificateVerify当需要做客户端认证时，客户端发送CertificateVerify消息，来证明自己确实拥有客户端证书的私钥。这条消息仅仅在客户端证书有签名能力的情况下发送 应用数据协议(application data protocol)应用数据协议携带着应用消息，只以TLS的角度考虑的话，这些就是数据缓冲区。记录层使用当前连接安全参数对这些消息进行打包、碎片整理和加密 警报协议(alert protocol)警报的目的是以简单的通知机制告知对端通信出现异常状况。它通常会携带close_notify异常，在连接关闭时使用，报告错误 附录 《图解HTTP》 HTTP | MDN 数字证书及CA的扫盲介绍 HTTPS 原理浅析及其在 Android 中的使用]]></content>
      <categories>
        <category>Network</category>
      </categories>
      <tags>
        <tag>Http</tag>
        <tag>Https</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[行·张家界]]></title>
    <url>%2F2018%2F05%2F20%2Ftravel-zjj%2F</url>
    <content type="text"><![CDATA[时间：2018.06.16——2018.06.19 地点：杭州——张家界 目标：武陵源景区，天门山景区，大峡谷景区 听说张家界是人间仙境，鬼斧神工，嗯，今年端午就去一探究竟，慌慌张张，匆匆忙忙做一份旅行攻略，翻遍百度，爬烂谷歌，都没有找到匹配的攻略，哎，可能是我姿势不对？！ 张家界，张家界景区共分为四块：张家界国家森林公园，杨家界自然保护区，天子山自然保护区，索溪峪自然保护区四大景区，统称为武陵源风景名胜。 最受欢迎 的四大景区 武陵源景区（森林公园、金鞭溪、袁家界、杨家界、天子山、十里画廊等） 天门山景区（亚州最长的索道、世界公路奇观、玻璃栈道等） 大峡谷风景区（新开发的玻璃桥） 凤凰古城 出行准备 身份证件等相关证件 数码产品，雨具等 简单洗漱用品及换洗衣物 现金若干（不必太多） 零食（必备：辣条） 注意事项由于是自由行的方式，因此提醒以下几点 到达张家界后，拒绝 和 一切 人搭话，避免一些麻烦，给行程带来不愉快 保管好自己的物品 张家界火车站出站后即可到汽车站乘坐大巴去武陵源景区，50分钟左右，10（森林公园）—12元（武陵源） 大峡谷，天门山景区玻璃桥都需要提前5天在网上预定 出行路线整体路线图路线一： Day1(16):天门山景区 Day2.Day3(17-18):武陵源景区 Day4(19):大峡谷风景区 路线二（推荐） Day1.Day2(16-17):武陵源景区 Day2.Day3(18):大峡谷风景区 Day4(19):天门山景区 标记说明 张家界火车站 武陵源景区 大峡谷风景区 天门山景区 武陵源景区路线门票：245 元+保险费3 元（3天内多次进出有效，含环保车票价）开放时间：8:00-17:00Day1：森林公园-金鞭溪-杨家界Day2：大观台-天子山-十里画廊-索溪湖-武陵源门票站从森林公园进，从武陵源出，不走回头路。需要在 丁香榕 住一宿 大峡谷风景区路线门票：大峡谷（门票122元）+玻璃桥（门票138元）开放时间：08:00-17:00Day3：玻璃桥-大峡谷 天门山景区路线门票：258.00元（含往返索道、环保车）【旺季】开放时间：08:00~16:00路线Day4：玻璃栈道-天门山寺-天门洞(坐索道上山顶——走西线——再到天门翻水处坐自动扶梯到天门洞——爬999级阶梯——最终坐环保车返回至市区)自备中午餐 住宿现在还未确定路线，个人推荐路线二；其次，16，17，18号需要住宿，要提前预定旅店 美食胡师傅三下锅三下锅，所谓的三下锅其实就是一种很方便的干锅，它是由三种主料做成的，炖着不放汤的火锅，三角坪附近的那个“胡师傅三下锅”味道不错，三下锅50元一份，分量很够吃的，包你吃够吃好！推荐的就是干煸肠子，干煸核桃肉和湘西腊肉三种混在一起炖，吃的同时还可以点一份酸萝卜，又脆又酸。真的是极品哦！（吃过后，发现并没有网上说的这么好吃，就是大烩菜，哈哈哈） 等等。。。 汇总 游记废话不说，武陵源景区不用去，虽说是5A景区，除了山还是山，而且商业气息很重，很多地方都不能步行，需要坐缆车，电梯等交通工具，况且这次去森林公园那边在修路，说是在修高铁，建议直接去 大峡谷风景区 和 天门山景区 武陵源景区整个武陵 大峡谷风景区 天门山景区(function(){var player = new DPlayer({"container":document.getElementById("dplayer1"),"theme":"#FADFA3","video":{"url":"https://res.cloudinary.com/incoder/video/upload/v1530682876/blog/travel/travel-zjj-tms.mp4"}});window.dplayers||(window.dplayers=[]);window.dplayers.push(player);})()]]></content>
      <categories>
        <category>Travel</category>
      </categories>
      <tags>
        <tag>张家界</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[构建基础SSM框架]]></title>
    <url>%2F2018%2F05%2F20%2Fssm%2F</url>
    <content type="text"><![CDATA[SSM结构 SSM框架整合所谓的SSM即：Spring，SpringMVC，Mybatis Spring：一个轻量级的框架，有很多的拓展功能，最主要的我们一般项目使用的就是IOC和AOP。 SpringMVC：Spring实现的一个Web层，相当于Struts的框架，但是比Struts更加灵活和强大. Mybatis：一个持久层的框架，在使用上相比Hibernate更加灵活，可以控制SQL的编写，使用 XML或注解进行相关的配置. 实战项目 项目功能： Spring,SpringMVC,Mybatis框架整合 Create Features Retrieve Features Update Features Delete Features 项目示例：rc-ssm 其他ajax之PUT请求客户端ajax方式发送PUT请求，Tomcat默认不会对请求进行处理；Tomcat： 将请求体中的数据，封装成一个map request.getParameter(“fileName”)就会从这个map中取值 springMVC封装POJO对象时，会把POJO中的属性的值，request.getParameter(“fileName”) 解决方式： 方式一：Ajax发送POST请求Ajax中type:”POST”data: $(“”).serialize()+”&amp;_method=PUT” 方式二：web配置中添加HttpPutFormContentFilter过滤器1.HttpPutFormContentFilter将请求体中的数据解析包装成一个map2.request被重新包装，request.getParameter()被重写，从自己封装的map中取出数据 获取属性的值prop修改和读取DOM原生属性的值attr修改和读取自定义属性的值]]></content>
      <categories>
        <category>Frame</category>
      </categories>
      <tags>
        <tag>Spring</tag>
        <tag>SpringMVC</tag>
        <tag>Mybatis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git 子仓库管理]]></title>
    <url>%2F2018%2F05%2F17%2Fgit-sub%2F</url>
    <content type="text"><![CDATA[在使用NexT作为Hexo博客的主题时，不能 友好 的支持其主题的更新，以及 多设备 之间的主题同步。按照官方提供的导入主题操作指引12$ cd hexo$ git clone https://github.com/theme-next/hexo-theme-next themes/next 发现commit并push到GitHub的远程服务器上，发现themes/next路径下并不能打开和查看该路径下的文件，原因是NexT是当前项目的一个子仓库(项目)，在Github上对于之仓库项目的引用，推荐使用git subtree命令来进行对子仓库的管理，不推荐直接拷贝需要子仓库的代码到自己的项目中 原因是我是使用Travis CI来部署自己的项目，具体的构建脚本和介绍请看，下面分别使用 git submodule、git subtree的方式进行NexT主题的管理 git submodule 与 git subtree git submodule、git subtree都可以实现一个仓库作为其他仓库的子仓库的管理 git submodule：是Git官方以前的推荐方案 git subtree：Git 1.5.2 开始，Git 新增并推荐使用这个功能来管理子项目 git subtree与git submodule不同，它不增加任何像.gitmodule这样的新的元数据文件 git subtree对于项目中的其他成员透明，意味着可以不知道git subtree的存在 git submodule 常用操作Git Submodule功能官方操作指引 add 一个submodule Fork Repositoryhexo-theme-next项目右上角Fork按钮即可 Clone Repository 1git clone git@github.com:RootCluster/hexo-theme-next.git Add Submodule 1234# 进入项目cd hexo-theme-next # 注册next项目是一个submodule，并把数据拷贝到`themes/next`路径git submodule add git@github.com:RootCluster/hexo-theme-next.git themes/next status 123# 当前submodule已被注册并指向了某个commitgit submodule status 1f5643061ec5257269673bd6159403c24015c53d themes/next (v6.3.0) 12345678# 查看在父仓库中有哪些变化被注册git statusOn branch submoduleChanges to be committed:(use "git reset HEAD &lt;file&gt;..." to unstage) new file: .gitmodules new file: themes/next 有2个文件被修改过：.gitmodules,themes/next，当在父仓库时，Git不会跟踪submodule中的文件，Git只把它当成一个单一的文件 .gitmodules:存有submodule的信息 themes/next:submodule它自己 commint 123456# 推送到远程submodule分支git commit -am "add next submodule"[submodule a5a612b] add next submodule 2 files changed, 4 insertions(+) create mode 100644 .gitmodules create mode 160000 themes/next push 123456789git push origin submoduleCounting objects: 4, done.Delta compression using up to 4 threads.Compressing objects: 100% (4/4), done.Writing objects: 100% (4/4), 451 bytes | 451.00 KiB/s, done.Total 4 (delta 1), reused 0 (delta 0)remote: Resolving deltas: 100% (1/1), completed with 1 local object.To github.com:RootCluster/hexo-themes-test.git 71879a8..a5a612b submodule -&gt; submodule 查看Github上的仓库，发现父仓库里有一个指向submodule的链接，表示你已经成功添加了一个submodule clone 带 submodule的项目新路径下，clone项目，submodule分支12345678# clone项目git clone -b submodule git@github.com:RootCluster/hexo-themes-test.git# 进入项目路径cd hexo-themes-test/# 项目注册submodulegit submodule init# clone submodule代码git submodule update update 带 submodule的项目只要在submodule路径下，所有的常规Git操作，如push,pull,reset,status等，都可以正常工作，如果要保证submodule和远程仓库保存同步，在submodule路径下运行git pull 如果你得到一个错误信息, 说你不在任何分支之上, 只要运行git checkout master就可修复 如果你在pull后 submodule 有一些更新, 父仓库会告诉你有一些变动需要 commit 了. submodule自身指向一个指定的 commit, 并且如果这个 commit 改变了, 父仓库会得知这个改变. 如果你的 submodule 需要在一个指定 commit 上工作, 可用git reset来设置 例如：我需要把NexT的版本改变到上一个Tag 6.2.0 (目前是6.3.0) git reset –hard (commit hash) 12345678# 进入项目路径cd hexo-themes-test/# 重新指向submodule关联的commit记录git reset --hard 206d463# 回到父目录cd ..# commit本次的修改git commit -am "set next version to 6.2.0" 推送到远程仓库后，submodule 会和指定的commit 关联起来。如果你和别人一起工作在同一个项目，别人也可以在submodule下pull并且commit，因此改变了submodule的commit指向，这个问题，可以通过git reset 来解决 remove 项目中的 submodule 项目的根目录下(不是 submodule 的目录)，编辑 .gitmodules 文件，删除submodule配置 123[submodule "themes/next"] path = themes/next url = https://github.com/RootCluster/hexo-theme-next.git 项目根目录下，编辑.git文件夹下config文件，删除submodule配置 12[submodule "themes/next"] url = https://github.com/RootCluster/hexo-theme-next.git 清除submodule缓存 1git rm --cached themes/next git subtree 常用操作(重点)add一个subtree 在父仓库中新增子仓库1234567891011# 添加子仓库git subtree add --prefix=themes/next https://github.com/RootCluster/hexo-theme-next.git master --squashgit fetch https://github.com/RootCluster/hexo-theme-next.git masterwarning: no common commitsremote: Counting objects: 3407, done.remote: Total 3407 (delta 0), reused 0 (delta 0), pack-reused 3406Receiving objects: 100% (3407/3407), 1.21 MiB | 36.00 KiB/s, done.Resolving deltas: 100% (2192/2192), done.From https://github.com/RootCluster/hexo-theme-next * branch master -&gt; FETCH_HEADAdded dir 'themes/next' --squash参数表示不拉取历史信息，而只生成一条commit信息 查看项目状态 1234567# 查看项目状态git statusOn branch subtreeYour branch is ahead of 'origin/subtree' by 2 commits. (use "git push" to publish your local commits)nothing to commit, working tree clean 推送更改到远程仓库 123456789git push origin subtreeCounting objects: 381, done.Delta compression using up to 4 threads.Compressing objects: 100% (334/334), done.Writing objects: 100% (381/381), 650.26 KiB | 34.22 MiB/s, done.Total 381 (delta 23), reused 225 (delta 19)remote: Resolving deltas: 100% (23/23), completed with 1 local object.To https://github.com/RootCluster/hexo-themes-test.git 8ed2e2e..405af42 subtree -&gt; subtree pull 子仓库更新12345# 更新子仓库git subtree pull --prefix=themes/next https://github.com/RootCluster/hexo-theme-next.git master --squashFrom https://github.com/RootCluster/hexo-theme-next * branch master -&gt; FETCH_HEADSubtree is already at commit 1f5643061ec5257269673bd6159403c24015c53d. push 子仓库修改在引用子仓库的项目中修改了子仓库的相关代码，推送修改到源仓库 commit 修改记录 push 到源仓库12# 推送子仓库修改到源仓库master分支git subtree push --prefix=themes/next https://github.com/RootCluster/hexo-theme-next.git master subtree 常用命令123456git subtree add --prefix=&lt;prefix&gt; &lt;commit&gt;git subtree add --prefix=&lt;prefix&gt; &lt;repository&gt; &lt;ref&gt;git subtree pull --prefix=&lt;prefix&gt; &lt;repository&gt; &lt;ref&gt;git subtree push --prefix=&lt;prefix&gt; &lt;repository&gt; &lt;ref&gt;git subtree merge --prefix=&lt;prefix&gt; &lt;commit&gt;git subtree split --prefix=&lt;prefix&gt; [OPTIONS] [&lt;commit&gt;] 学习参考附录： 如何使用 Git Submodule git subtree教程]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>git subtree</tag>
        <tag>git submodule</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux 常用应用安装]]></title>
    <url>%2F2018%2F05%2F15%2Flinux-build%2F</url>
    <content type="text"><![CDATA[作为Android开发者，目标主要是在客户端，平时也就是和服务端对接数据接口，很少直接干到服务端的Linux机器，随着这波推动团队技术平台基础开发工具模块的完善，拿到了一台Linux机器，重新构建移动端的测试服务器。 该机器主要功能： 提供移动端服务Api接口 提供移动端通讯录管理授权服务 提供企业微信通讯录同步服务 管理移动端服务器Api接口文档 也是第一次正式的从头开始安装所需软件及应用部署，虽然这些工作可以完全找运维去处理，难得这样的机会从头开始去熟悉Linux。 安卓，是一个基于Linux内核的开放源代码移动操作系统，因此多了解Linux是一件双赢的事情，基于当前机器需要提供的服务，安装部署需要的软件应用 废话不多说，上来就是干 查看当前系统版本信息1lsb_release -a 以下软件版本，请下载对应支持系统的软件 Java官方下载地址，选择需要的版本下载安装包 官方提供了.rpm,.gz两种格式安装包 1234567891011121314151617# 1.下载安装包# 拷贝安装包到需要安装的服务器# 2.解压并安装# `.rpm`格式安装(jdk-xxx.rpm更换成对应的文件名)sudo rpm -ivh jdk-xxx.rpm# `.gz`格式安装(解压到指定目录，常存放`/usr/java/`路径)tar zxvf jdk-xxx.tar.gz -C /usr/java/# 3.设置环境变量vim /etc/profile# JAVA_HOME=/usr/java/jdk1.8.0_172 (修改这里路径，指向jdk安装路径)# PATH=$JAVA_HOME/bin:$PATH# CLASSPATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar# export JAVA_HOME PATH CLASSPATH# 4.编译配置文件，使修改生效source /etc/profile# 5.验证jdk是否安装成功java –version Tomcat官方下载地址，选择需要的版本下载安装包 官方提供了.zip,.gz两种格式安装包，Linux服务器下载Core类即可 123456789# 1.下载安装文件wget http://mirrors.hust.edu.cn/apache/tomcat/tomcat-9/v9.0.8/bin/apache-tomcat-9.0.8.tar.gz# 2.解压安装文件(解压到指定目录，常存放`/usr/tomcat/`路径)tar -zxvf apache-tomcat-9.0.8.tar.gz -C /usr/tomcat/# 3.启动tomcatcd /usr/local/tomcat/bin./startup.sh# 4.关闭tomcat./shutdown.sh 配置Web管理账号 修改文件conf/tomcat-users.xml，在元素中添加帐号密码，需要指定角色1234vim /usr/local/tomcat/conf/tomcat-users.xml# &lt;tomcat-users&gt;# &lt;user name="admin" password="admin" roles="admin-gui,manager-gui" /&gt;# &lt;/tomcat-users&gt; 配置端口 可以修改conf目录下的文件server.xml，修改Connector元素(Tomcat的默认端口是8080)，需要重新启动Tomcat服务生效12vim /usr/local/tomcat/conf/server.xml# &lt;Connector port="9999" protocol="HTTP/1.1" connectionTimeout="20000" redirectPort="8443" /&gt; 应用部署 放置需部署包到容器中webapps路径 1cd /usr/local/tomcat/webapps 启动服务 12cd /usr/local/tomcat/bin./startup.sh Apache一般系统中以及包含apache应用官方下载地址，选择需要的版本下载安装包 官方提供了.bz2,.gz两种格式安装包 安装查看系统中是否已包含httpd应用1rpm -qa | grep httpd 或 yum list | grep httpd 方式一 1234# 1.下载需要的版本文件wget http://apache.claz.org//httpd/httpd-2.4.33.tar.gz# 2.解压安装文件(解压到指定目录，常存放`/usr/local/httpd/`路径)tar -zxvf httpd-2.4.33.tar.gz -C /usr/local/httpd/ 方式二(推荐) 12# 1.下载安装httpdyum install httpd 卸载1yum erase httpd.x86_64 或 rpm -e httpd.x86_64 常用命令123456# 查看服务运行状态systemctl status httpd.service# 启动apache服务systemctl start httpd.service# 停止apache服务systemctl stop httpd.service RPM默认安装路径： 路径 说明 /etc 一些设置文件放置的目录如/etc/crontab /usr/bin 一些可执行文件 /usr/lib 一些程序使用的动态函数库 /usr/share/doc 一些基本的软件使用手册与帮助文档 /usr/share/man 一些man page文件 Nginx官方下载地址，选择需要的版本下载安装包(最新安装版本1.14.0) 官方提供了.zip,.gz两种格式安装包 安装 方式一 1234567# 1.下载安装文件wget http://nginx.org/download/nginx-1.14.0.tar.gz# 2.解压安装文件(解压到指定目录，常存放`/usr/local/`路径)tar -zxvf nginx-1.14.0.tar.gz -C /usr/local/# 3. 编译安装依赖库cd /usr/local/nginx/./configure 方式二 12# 默认安装路径/etc/nginx/yum install nginx 常用命令 加压文件安装常用命令 12345678910# 停止ngix/usr/local/nginx/sbin/nginx -s quit# 重新载入nginx(当配置信息发生修改时) /usr/local/nginx/sbin/nginx -s reload# 查看版本 /usr/local/nginx/sbin/nginx -v# 查看nginx的配置文件的目录 /usr/local/nginx/sbin/nginx -t# 查看帮助信息 /usr/local/nginx/sbin/nginx -h yum安装常用命令 12345678910# 启动systemctl start nginx# 停止 systemctl stop nginx# 重启 systemctl restart nginx# 查看运行状态 systemctl status nginx# 开机启动 systemctl enable nginx Node一般系统中以及包含apache应用官方下载地址，选择需要的版本下载安装包 官方提供了.gz,.7z,zip等多种格式安装包 安装1234567# 1.下载安装文件wget https://nodejs.org/download/chakracore-release/v8.6.0/node-v8.6.0-linux-x64.tar.gz# 2.解压安装文件(解压到当前目录)tar -zxf node-v8.6.0-linux-x64.tar.gz# 3.建立软链接，实现全局访问ln -s /root/node-v8.6.0-linux-x64/bin/node /usr/local/bin/nodeln -s /root/node-v8.6.0-linux-x64/bin/npm /usr/local/bin/npm Redis官方下载地址，选择需要的版本下载安装包 官方提供了.gz格式安装包 安装123456789# 1.下载安装文件wget wget http://download.redis.io/releases/redis-4.0.10.tar.gz# 2.解压安装文件(解压到当前目录)tar xzf redis-4.0.10.tar.gz# 3.编译安装cd redis-4.0.10make# 4.启动服务src/redis-server 配置12# 1.修改redis.conf文件中daemonize属性 为 yesvim /you_install_path/redis.conf 其他配置根据自身需要调整修改 其他命令 关闭服务 1redis-cli -h 127.0.0.1 -p 6379 shutdown 非安全模式启动 12# 后台以非安全模式启动nohup /usr/local/bin/redis-server --protected-mode no &amp; 常用命令文件查找findfind命令是根据文件的属性进行查找，如文件名，文件大小，所有者，所属组，是否为空，访问时间，修改时间等。 基本格式：find path expression 示例： 在根目录下查找文件httpd.conf，表示在整个硬盘查找find / -name httpd.conf 表示当前目录下查找文件名开头是字符串‘srm’的文件find . -name ‘srm*’ 查找在系统中最后10分钟访问的文件(access time)find / -amin -10 查找在系统中属于fred这个用户的文件find / -user fred 查找出小于1000KB的文件find / -size -1000k grepgrep是根据文件的内容进行查找，会对文件的每一行按照给定的模式(patter)进行匹配查找。 基本格式：find expression 主要参数： －c：只输出匹配行的计数。 －i：不区分大小写 －h：查询多文件时不显示文件名。 －l：查询多文件时只输出包含匹配字符的文件名。 －n：显示匹配行及行号。 －s：不显示不存在或无匹配文本的错误信息。 －v：显示不包含匹配文本的所有行。 示例： 显示所有包含每行字符串至少有5个连续小写字符的字符串的行grep ‘[a-z]{5}’ aa 显示所有以d开头的文件中包含 test的行grep ‘test’ d* 进程相关 查看指定服务进程 1234# 查看httpd服务进程ps -ef | grep httpd# UID PID PPID C STIME TTY TIME CMD# root 7192 7103 0 19:59 pts/3 00:00:00 grep --color=auto httpd UID：用户ID PID：进程ID PPID：父进程ID C：CPU用于计算执行优先级的因子。数值越大，表明进程是CPU密集型运算，执行优先级会降低；数值越小，表明进程是I/O密集型运算，执行优先级会提高 STIME：进程启动的时间 TTY：完整的终端名称 TIME：CPU时间 CMD：完整的启动进程所用的命令和参数 杀死指定进程 1kill -9 pid（逐个都删除） 查看指定端口 12# 检测6379端口是否在监听 netstat -lntp | grep 6379]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Build</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo Blog 迭代]]></title>
    <url>%2F2018%2F05%2F02%2Fhexo-iterative%2F</url>
    <content type="text"><![CDATA[最初博客通过Cloudflare反向代理进行HTTPS解析，放完五一假期，Github官方开始支持自定义域名的HTTPS解析，在使用Cloudflare期间，经常性的521等问题烦恼，这次也可以名正言顺的弃用CloudFlare 本次迭代内容 弃用Cloudflare 自动化部署 常用设置 常用插件安装 弃用Cloudflare 关闭Cloudflare中设置Page Rules 删除Cloudflare的DNS记录 还原域名配置中的DNS解析 添加Github提供的IP解析 官方自定义域名设置 自动化部署 Github Pages是Github 提供一个渲染静态的Web页面服务 {username}.github.io仓库默认master分支 其他项目仓库，默认gh-pages分支 官方说明文档 因此{username}.github.io仓库，dev分支用来存储网站的源码，master分支存放生成的静态文件，这样一个仓库就可以管理整个项目。每次push新的功能，然而每次都需要先push到dev分支，然后生成静态文件，再push到master分支，这种重复性的操作，实在太不优雅，所以采用Travis CI进行自动化部署 接着Github支持自定义域名开启HTTPS的好消息，Travis CI (https://travis-ci.com) 也支持开源项目啦 Travis CI 区别 Travis-CI(https://travis-ci.org) ：GitHub公开项目 Travis-CI(https://travis-ci.com) ：私有付费项目，2018.05.02也开始支持开源项目 GitHub Services are being deprecated，因此本节的自动化部署就开启Travis CI (https://travis-ci.com) 集成方案 准备 使用GitHub账号登录Travis-CI，并确认接受访问 同步了GitHub存储库，转到您的配置文件页面并启用您想要构建的存储库 添加 .travis.yml 文件到构建部署项目的根目录下 Hexo 自动部署部署流程 Hexo 部署脚本示例123456789101112131415161718192021222324252627282930language: node_js # 设置语言node_js: stable # 设置相应的版本cache: directories: - node_modulesbefore_install: - npm install -g hexo - npm install -g hexo-cliinstall: - npm install # 安装hexo及插件before_script: - npm install -g mocha - git clone --branch master https://github.com/BladeCode/BladeCode.github.io.git publicscript: - hexo cl # 清除 - hexo g # 生成after_script: - cd ./public - git init - git config user.name "BladeCode" # 修改成自己的github用户名 - git config user.email "Jerry.x@outlook.com" # 修改成自己的GitHub邮箱 - git add . - git commit -m "update by Travis-CI" # 更新日志 - git push --force --quiet "https://$&#123;GH_TOKEN&#125;@$&#123;GH_REF&#125;" master:master # GH_token就是在travis中设置的tokenbranches: only: - dev # 只监测dev分支，一有动静就开始构建env: global: - GH_REF: github.com/BladeCode/BladeCode.github.io.git 常用设置NexT 配置使用手册 NexT主题更新官方说明 常用插件安装 文章字符统计 hexo-symbols-count-time 修复LeanCloud访客计数器中的严重安全漏洞 hexo-leancloud-counter-security 图片灯箱 theme-next-fancybox3 本地检索 hexo-generator-searchdb 其他图床选择 个人网站中的静态文件云存储选择 嗯，图片就交给它了 NexT主题无法备份解决方式]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Build</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[忆·黄山]]></title>
    <url>%2F2018%2F05%2F01%2Fmemory-hs%2F</url>
    <content type="text"><![CDATA[黄山归来不看岳 五岳未归，先品黄山。以前看黄山还是小学课本《黄山》一文介绍黄山的美，黄山的秀丽，黄山的与众不同，这次是亲身去体验黄山的姿态；趁着五一，趁着年轻，趁着…。废话不多讲，先看黄山日出美景 (function(){var player = new DPlayer({"container":document.getElementById("dplayer0"),"theme":"#FADFA3","video":{"url":"https://res.cloudinary.com/incoder/video/upload/v1528018149/blog/video/HuangShan-Sunrise.mp4","pic":"https://res.cloudinary.com/incoder/image/upload/v1528024134/blog/travel/travel-huangshan-back.jpg"}});window.dplayers||(window.dplayers=[]);window.dplayers.push(player);})() 别问我为啥抖，没有支撑点，全程手持…逃 这次黄山之行并没有做任何功课，计划到实施前后不超过15天，抱着走一步，看一点的心态去玩，没想到五一节假日，来黄山的人不是很多。 出行方式杭州 城西客运站 做大巴直达黄山景区，票价：￥110，时间：大约4小时左右到达 攻略逃，没有……由于到达黄山游客集散中心已是14：00，由于距离黄山还有10多公里，你可以走路去黄山山脚下，而且16：00之后没有大巴去黄山景区。因此随便找了个地吃完中午饭，就往乘大巴车黄山景区去了（￥12/人），由于上山的入口有好几个，我们也没有去研究，大巴到 云谷寺 景区，我们也就下车从这里出发往山上去了，你可以坐缆车去往山顶，我们一行三人，选择了徒步上山，对了门票：￥230/人 一路说说笑笑，也没有预订上山的旅店，我们心真大，刚走了没多久，就看到了两个人被交椅抬着下山了，其中一个应该是摔了，头破血流的样子，还没开始，就…；没多管，一路还是很轻松，毕竟都是年轻人，体力不错，走到 白鹅岭 已经开始下雨，雨越下越大，因为在边走边看的路上，我们决定来黄山当然是去 迎客松 的景点，然后我们顺着 白鹅岭 前往 白鹅山庄旅游商场 去避雨，然后是人多的无法挪开脚，此时天色已晚，我们稍作休息，找了半天也没有能睡得地，那床都是人挤人。我们找了个茶馆，吃了些带着的食品，喝了一小时茶，大约20：00左右，我们决定，今晚夜行到 迎客松 雨后起了大雾，山顶那时雾色正浓，能见度大约在3米。我们三人也紧随其形，在 光明顶 片区玩了一会，这里看日出不错，当我们并没有这里等日出，毕竟这里离 迎客松 有一小时多的行程，我们要明天早早的在 迎客松 那里拍照装逼，拍完照然后回走去最高峰 莲花峰 ，然而到了 迎客松 才发现，并不像电视上看到的，是在山的悬崖边。好了，这会才23：00多，怎么办，还有好几小时，又没有帐篷什么地可住，三人就在这 迎客松 前的广场上，发现了超大遮阳伞两把，哈哈哈，我们就用遮阳伞前后堵住，加上自己的雨伞，构建了一个堡垒，这下，我们三可用在里面睡觉了，雨后的山上很潮湿，就这样半将半究的，坚持到4点多。 天快要亮了，要找地儿去拍日出，我答应别人了，要发日出照片给她，往回走去 莲花峰 那里并不合适，更重要的是山路也被封，不上上去，只好找到 玉屏索道 的另一条路上，这里刚刚好可用看到日出 拍完日出，我们快速折回到 迎客松 ，那里已经开始有三三两两的人了，我们动作要快，否则等会从索道上来大批人马，嗯，快速装逼完成，迅速撤离战场]]></content>
      <categories>
        <category>Memory</category>
      </categories>
      <tags>
        <tag>黄山</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[品·杭州]]></title>
    <url>%2F2018%2F04%2F29%2Fmemory-hz1%2F</url>
    <content type="text"><![CDATA[上有天堂，下游苏杭，杭州，一个温文尔雅，一个记忆中天堂，一个南方姑娘的城市。杭州：毕业后的第二个城市，很开心在这样的城市生活，工作，结识这里的人，杭州和家乡的气候非常相似，因此在杭州有种在家的感觉，在这里遇到的的人，我都会记着你们美丽帅气的脸庞 18年是一个动荡的一年，一起的伙伴渐渐的离开了昔日的团队，这两年中，有的人毕业，有的人结婚，有的人生子，有的人成长，感谢我能成为你们生命中的一个过客，和你们一起经历生活百态 不管你们在何方，从事着什么样的工作，过着什么样的生活，我会想你们，愿你们的一切顺利 粗略的剪影，请异步优酷 不遵守规则的人，我们叫他废物，但是，不珍惜同伴的人，连废物都不如——宁智波·带土]]></content>
      <categories>
        <category>Memory</category>
      </categories>
      <tags>
        <tag>杭州</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Gitlab 应用搭建]]></title>
    <url>%2F2018%2F04%2F24%2Fgitlab1%2F</url>
    <content type="text"><![CDATA[我司团队之前一直使用SVN来进行代码托管，主要问题 每次来个新人都需要找对应的SVN管理员进行授权分配指定的仓库操作权限，有时候需要多个项目切换，还得再次提出进行仓库的指定 SVN都是以中文命名，这其实没啥，但是在eclipse 以及IDEA ，Xcode等开发工具，链接地址都会把中文字进行编码，造成路径非常的长，强迫症的我这怎么忍得了 产品相关的，设计相关的啥也都放在SVN里面，搞得SVN里面鱼龙混杂 因此在我提出及建议下，部门经理同意了对代码的管理进行隔离方便有效的对代码的授权监管，并同时制定代码的相关规范和服务的自动化部署等，提高团队的开发效率和代码质量。 本节主要介绍Gitlab的环境搭建和基础的功能配置 目的： 搭建Gitlab服务 和公司AD域账号关联，用域账号直接登录Gitlab 挂载Gitlab 仓库到指定存储位置 Gitlab安装环境 OS：CentOS 7 Gitlab：Gitlab CE 10.6.4 Gitlab 版本 Gitlab Community Edition (CE)：社区版，免费，用户自行托管，通过社区提供技术支持 Gitlab Enterprise Edition (EE)：企业版，付费，用户自行托管，提供附加的功能以及技术支持 Gitlab.com：免费的SaaS服务，可以创建共有以及私有的版本库，可以购买额外的技术支持 GitHost.io：由Gitlab提供的用户私有的独享服务 Gitlab部署 系统防火墙中打开HTTP和SSH访问 123456sudo yum install -y curl policycoreutils-python openssh-serversudo systemctl enable sshdsudo systemctl start sshdsudo firewall-cmd --permanent --add-service=httpsudo systemctl reload firewalld 安装Postfix发送通知邮件。如果您想使用其他解决方案发送电子邮件，请跳过此步骤并在安装GitLab后配置外部SMTP服务器 123sudo yum install postfixsudo systemctl enable postfixsudo systemctl start postfix 添加GitLab软件包存储库 1curl -LJO https://mirrors.tuna.tsinghua.edu.cn/gitlab-ce/yum/el7/gitlab-ce-10.0.0-ce.0.el7.x86_64.rpm 安装软件包 1rpm -i gitlab-ce-10.0.0-ce.0.el7.x86_64.rpm 完成安装如下日志显示： 1234567891011121314151617181920 *. *. *** *** ***** ***** .****** ******* ******** ******** ,,,,,,,,,***********,,,,,,,,,,,,,,,,,,,,*********,,,,,,,,,,,.,,,,,,,,,,,*******,,,,,,,,,,,, ,,,,,,,,,*****,,,,,,,,,. ,,,,,,,****,,,,,, .,,,***,,,, ,*,. _______ __ __ __ / ____(_) /_/ / ____ _/ /_ / / __/ / __/ / / __ \`/ __ \/ /_/ / / /_/ /___/ /_/ / /_/ /\____/_/\__/_____/\__,_/_.___/ 编译配置文件 12cd /opt/gitlab/bin./gitlab-ctr reconfigure 启动服务 1./gitlab-ctl start 成功启动服务，默认路径访问：http://localhost:80 默认安装位置 /opt/gitlab/ 配置文件默认路径 /etc/gitlab/gitlab.rb 默认账号：root，密码：5iveL!fe 常用配置项修改以下配置项的修改，完成后均需要重新编译文件（配置文件默认路径 /etc/gitlab/gitlab.rb），默认，并重启Gitlab服务 访问地址修改external_url为Gitlab对应机器IP所配置的域名 LDAP启用修改host,port,bind_dn,password,base参数即可 各参数解释： host 和 port 是 LDAP 服务的主机地址及端口 bind_dn 和 password 是一个管理 LDAP 的 dn 及密码 base 表示 LDAP 将以该 dn 为 节点，向下查找用户 user_filter 表示以某种过滤条件筛选用户 attributes 表示 GitLab 中的字段与 LDAP 中哪些字段可以相互对应，比如可以用 LDAP 中的 uid 来作为 GitLab 用户名 编译重启后，查看登录是否已经显示LDAP登录入口 为了安全我们需要关闭 GitLab 自己的注册功能，这样新用户只能通过 LDAP 认证的方式进行登陆。 存储仓库修改默认仓库存储位置：/var/opt/gitlab/git-data/repositories/ Gitlab日志默认日志位置： /var/log/gitlab 12cd /opt/gitlab/bingitlab-ctl tail -f nginx/gitlab_access.log 或者在Gitlab服务的系统设置中查看 附录 官方安装教程 官方配置文件]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Gitlab</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Realm 数据库快速上手]]></title>
    <url>%2F2018%2F04%2F24%2Frealm%2F</url>
    <content type="text"><![CDATA[Android 供了多种选项来保存永久性应用数据。 Shared preferences Internal file storage External file storage Databases Network 其中数据库存储是一种必备技能，而衍生的mobile db也是层出不穷，本节主要介绍全平台(除Android,iOS,macOS外还支持web,桌面应用)Realm数据库在Android上的使用 快速上手 Android Studio 1.5.1+ JDK1.7+ Android API 9+ Realm 默认情况下使用内部存储（internal storage)，一般来说，这个文件位于/data/data/&lt;packagename&gt;/files/，文件名：default.realm 集成 在项目的 build.gradle 文件中添加如下 class path 依赖 12345678buildscript &#123; repositories &#123; jcenter() &#125; dependencies &#123; classpath "io.realm:realm-gradle-plugin:5.0.0" &#125;&#125; 在 app 的 build.gradle 文件中应用 realm-android 插件 1apply plugin: 'realm-android' 初始化 默认初始化 12345678public class MyApplication extends Application &#123; @Override public void onCreate() &#123; super.onCreate(); // 默认Realm的配置文件 Realm.init(this); &#125;&#125; 自定义初始化 1234567891011121314151617181920public class MyApplication extends Application &#123; @Override public void onCreate() &#123; super.onCreate(); // 自定义配置Realm initRealm(); &#125; private void initRealm() &#123; RealmConfiguration config = new RealmConfiguration.Builder() .name("myrealm.realm") // 命名文件名：myrealm.realm .inMemory() // 一个非持久化的、存在于内存中的 Realm 实例 .encryptionKey(getKey()) // 数据库加密key .schemaVersion(2) // 数据库结构版本号 .modules(new MySchemaModule()) // 数据库结构对象 .migration(new MyMigration()) // 数据库迁移 .build(); Realm.setDefaultConfiguration(config); &#125;&#125; Realm 实例是线程单例化的，也就是说多次在同一线程调用静态构建器会返回同一 Realm 实例 使用同样的名称同时创建“内存中的”Realm 和常规的（持久化）Realm 是不允许的 字段类型Realm 支持以下字段类型：boolean、byte、short、int、long、float、double、String、Date和byte []。整数类型 short、int 和 long 都被映射到 Realm 内的相同类型（实际上为 long ）。 @Required修饰类型和空值（null） Realm强制禁止空值（null）被存储 只有Boolean,Byte,Short,Integer,Long,Float,Double,String,byte[],Date可被修饰 @Ignore标识一个字段不应该被保存到 Realm @Index为字段增加搜索索引 仅支持索引的属性类型包括：String,byte,short,int,long,boolean和Date @PrimaryKey 必须为字符串（String）或整数（short,int,long）以及它们的包装类型（Short,Int,Long） 声明Realm数据模型RealmObject可以把RealmObject 当作POJO使用 123public class User extends RealmObject &#123;&#125; RealmModel1234@RealmClasspublic class User implements RealmModel &#123;&#125; 关系多对一12345678910public class Contact extends RealmObject &#123; private Email email; // Other fields…&#125;public class Email extends RealmObject &#123; private String address; private boolean active; // ... setters and getters left out&#125; 多对多123456789public class Contact extends RealmObject &#123; public String name; public RealmList&lt;Email&gt; emails;&#125;public class Email extends RealmObject &#123; public String address; public boolean active;&#125; CRUD 所有的写操作（添加、修改和删除对象），必须包含在写入事务（transaction）中 在提交期间，所有更改都将被写入磁盘，并且，只有当所有更改可以被持久化时，提交才会成功。通过取消一个写入事务，所有更改将被丢弃。 益于 Realm 的 MVCC 架构，当正在进行一个写入事务时读取操作并不会被阻塞！这意味着，除非你需要从多个线程进行并发写入操作，否则，你可以尽量使用更大的写入事务来做更多的事情而不是使用多个更小的写入事务。 增 事务执行 123456789Realm realm = Realm.getDefaultInstance();realm.executeTransaction(new Realm.Transaction() &#123; @Override public void execute(Realm realm) &#123; User user = realm.createObject(User.class); user.setName("John"); user.setEmail("john@corporation.com"); &#125;&#125;); 异步事务 12345678910111213141516171819Realm realm = Realm.getDefaultInstance();realm.executeTransactionAsync(new Realm.Transaction() &#123; @Override public void execute(Realm bgRealm) &#123; User user = bgRealm.createObject(User.class); user.setName("John"); user.setEmail("john@corporation.com"); &#125;&#125;, new Realm.Transaction.OnSuccess() &#123; @Override public void onSuccess() &#123; // Transaction was a success. &#125;&#125;, new Realm.Transaction.OnError() &#123; @Override public void onError(Throwable error) &#123; // Transaction failed and was automatically canceled. &#125;&#125;); OnSuccess 和 OnError 并不是必须重载的，重载了的回调函数会在事务成功或者失败时在被调用发生的线程执行。 删改查Realm进阶Realm云]]></content>
      <categories>
        <category>DataBase</category>
      </categories>
      <tags>
        <tag>Realm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[.gitignore 基础知识]]></title>
    <url>%2F2018%2F04%2F13%2Fgitignore%2F</url>
    <content type="text"><![CDATA[.gitignore顾名思义是Git中用来管理所需要忽略或者说不用纳入版本控制文件 基本配置语法 “#“：表示注释 “/“：表示目录 “*“：表示通配符，用来通配多个字符 “?“：表示通配单个字符 “[]“：表示包含单个字符的匹配列表 “!“：表示不忽略匹配到的文件或者目录 注意：Git对.gitignore配置文件是从上往下进行规则匹配，这也意味如果：前（limit）&gt;后（limit），则后面的规则不会被执行 全局与局部.gitignore分为： 全局 ignore，局部 ignore 全局ignore设置 在用户账户文件夹（C:\Users\&lt;’YourName’&gt;）路径下新建一个命名为.gitignore_global的文件 使用Git Bash(需要切换路径到C:\Users\&lt;’YourName’&gt;)或者Git CMD命令行工具输入： 1git config --global core.excludesfile ~/.gitignore_global 此时全局ignore已经设置完成，你只需要修改.gitignore_global文件内需要忽略的文件类型就可以全局控制忽略不需要纳入版本控制的文件或文件夹 不难发现，其实是往 .gitconfig中加入如下内容来指名Git忽略不纳入版本控制的文件，当然如果你不想用命令行完成全局设置，你也可以直接在.gitconfig文件中加入[core] excludesfile= ~/.gitignore_global内容即可 局部ignore设置 只需要在Git控制版本控制项目的根目录中加入.gitignore文件，在.gitignore文件中写明忽略不纳入版本控制的文件即可 参考示例 你可以查看参考Github官方所写好的示例 插件.ignore支持Android Studio，JetBrains系列安装方法 Settings &gt; Plugs &gt; Browse repositories &gt; .ignore &gt; Install plugin 里面有已经写好的模板，只需适当修改]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>ignore</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Api 文档管理系统 RAP2环境搭建]]></title>
    <url>%2F2018%2F03%2F27%2Frap2%2F</url>
    <content type="text"><![CDATA[RAP2是采用前后端分离的形式，因此搭建完整的RAP2需要 服务端：rap2-delos，客户端：rap2-dolores 同时部署 部署RAP2需要亲具有Node+Linux+MySQL的运维知识，如果亲对此不是很了解，建议用http://rap2.taobao.org 线上版本就可以 由于 客户端：rap2-dolores 是建立在 服务端：rap2-delos 基础上，因此先搭建服务端应用 截至到2018-08-01 delos 并没有发布Tag版本，应该还处于功能开发前期阶段吧。本教程是在CentOS机器上实战部署 然而安装部署并不是顺利，因此记录踩过的坑（别问我为啥不用Docker，因为我司分配的机器无法满足Docker的最低内核版本），安装环境介绍：Redis，delos，dolores均在一台服务器，MySQL使用已存在的服务 安装基本工具 Git Node 8.9.4+ Redis 4.0+ MySQL 5.7+ 以上基本工具请根据自身需要，下载对应系统安装包，请自行解决安装配置等问题，这里不做过多说明 Redis 安装可参考Linux 常用应用安装；Redis 最好用非安全模式启动 服务端delos环境搭建构建项目 构建项目前，请确认Node，Redis，MySQL服务均能正常使用 1git clone https://github.com/thx/rap2-delos.git 环境配置创建数据库 Mac or Linux 1mysql -e 'CREATE DATABASE IF NOT EXISTS RAP2_DELOS_APP DEFAULT CHARSET utf8 COLLATE utf8_general_ci'; Windows 环境 进入mysql命令后执行 1CREATE DATABASE IF NOT EXISTS RAP2_DELOS_APP DEFAULT CHARSET utf8 COLLATE utf8_general_ci; 配置文件目录：rap2-delos/src/config文件：config.dev.ts;其中dev，表示开发环境，其他同理修改：config.dev.ts文件中db对象中username，password参数与本地或者开发环境的数据库信息匹配 启动项目安装项目依赖包项目根目录下执行 1234# 安装项目所需依赖npm install# 全局安装PM2npm install -g pm2 安装TypeScript编译包1npm install typescript -g 如果下载缓慢，请使用淘宝npm镜像 初始化数据库项目根目录下执行(该过程比较慢，耐心等待初始化完成) 1npm run create-db 编译启动项目执行mocha测试用例和js代码规范检查1npm run check 开发模式启动开发模式的服务器 监视并在发生代码变更时自动重启(第一次运行比较慢，请耐心等待) 1npm run dev 生产模式 启动生产模式服务器 1npm start 看到浏览器中如下提示，表示服务端delos已经部署成功 RAP2后端服务已启动，请从前端服务(rap2-dolores)访问。 RAP2 back-end server is started, please visit via front-end service (rap2-dolores). 或者在程序控制台出现如下Log，表示服务端delos已经部署成功 常见问题部署问题 Windows下执行npm run build，提示&#39;rm&#39; 不是内部或外部命令，也不是可运行的程序或批处理文件 原因：rm 是Linux下命令， 解决方法：Windows系统可使用 git bash 打开该项目，执行该命令 执行npm run create-db命令，提示Unable to connect to the database:{ SequelizeAccessDeniedError: Access denied for user &#39;root&#39;@&#39;localhost&#39; (using password:NO)} 原因：未修改rap2-delos/src/config目录下数据库配置文件，或者是与文件中的数据库信息与之连接的数据库信息不匹配 解决方法：修改config.dev.ts文件数据库配置信息 如果修改正确无误后，执行npm run create-db依旧出错，那么查看该项目中是否已经存在dist目录，如果有，请按照如上修改对应的数据库配置信息 执行npm run dev命令，提示Error: listen EADDRINUSE :::8080 原因：8080端口被占用 解决方法：杀掉占用8080端口的应用 执行npm install 命令，提示hiredis 编译无法通过 原因：无权限操作rap2-delos/node_modules/hiredis路径 解决方法：sudo npm install 如果提示sudo: npm: command not found，请参考stackoverflow-npm,stackoverflow-node 执行npm run dev可以正常启动，npm start命令无法正常启动服务 原因：请使用pm2 logs查看日志具体定位 示例：由于Redis的安全模式，不能正常使用 1234567ReplyError: Ready check failed: DENIED Redis is running in protected mode because protected mode is enabled, no bind address was specified, no authentication password is requested to clients. In this mode connections are only accepted from the loopback interface. If you want to connect from external computers to Redis you may adopt one of the following solutions: 1) Just disable protected mode sending the command 'CONFIG SET protected-mode no' from the loopback interface by connecting to Redis from the same host the server is running, however MAKE SURE Redis is not publicly accessible from internet if you do so. Use CONFIG REWRITE to make this change permanent. 2) Alternatively you can just disable the protected mode by editing the Redis configuration file, and setting the protected mode option to 'no', and then restarting the server. 3) If you started the server manually just for testing, restart it with the '--protected-mode no' option. 4) Setup a bind address or an authentication password. NOTE: You only need to do one of the above things in order for the server to start accepting connections from the outside. 解决方法： 使用--protected-mode no方式启动 客户端dolores环境搭建构建项目获取源代码1git clone https://github.com/thx/rap2-dolores.git 环境配置配置文件目录：rap2-dolores/src/config文件：config.dev.ts;其中dev，表示开发环境，其他同理修改：config.dev.ts文件，serve地址是 服务端 rap2-delos 部署成功后的地址，默认：&#39;http://localhost:8080&#39; 启动项目安装项目依赖包项目根目录下执行 1npm install 如果下载缓慢，请使用淘宝npm镜像 编译启动项目 开发模式自动监视改变后重新编译 1npm run dev 备注：测试用例 1npm run test 生产模式编译React生产包 1npm run build 用serve命令或nginx服务器路由到编译产出的build文件夹作为静态服务器即可 1serve -s ./build -p 80 看到浏览器中出现登录页面，表示部署成功 常见问题部署问题 执行npm run dev，提示 123return process.dlopen(module,path._makeLong(filename))......node_modules\node-sass\vendor\win32-x64-57\binding.node is not a valid Win32 application... 原因：项目依赖包node-sass没有安装完全 解决方法：npm install node-sass 项目运行起来，但一直停留在加载动画那里 浏览器控制台输出： GET http://127.0.0.1:8080/account/info ==&gt;&gt; Failed to load http://127.0.0.1:8080/account/info 原因：未修改rap2-delos/src/config目录下服务端连接地址,或者修改结果与rap2-dolores实际提供服务地址不匹配 解决方法：修改config.dev.ts文件serve配置信息 如果Windows系统修改正确无误后，依旧出错，那么查看hosts(路径：C:\Windows\System32\drivers\etc)中127.0.0.1的IP前是否有#，如果有请取消注释 其他MySQL 运行问题 错误一原因：MySQL 集成命令没有加入系统的环境变量解决方法：将安装的MySQL Service路径加入系统变量 错误二原因：没有数据库链接权限解决方法：先登录用root数据库，密码具体看自己数据库当时设置的密码 如何获取更新目前请选择master分支源码，后续其他分支请看相应分支说明文档。在开发环境中git pull来获取最新的源码更新，每一期更新都会有对应的update.md请关注并按照上面的指示进行升级工作。 附录 redis如何后台启动 Redis配置文件介绍 PM2实用入门指南]]></content>
      <categories>
        <category>Api</category>
      </categories>
      <tags>
        <tag>RAP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Api 文档管理系统 RAP1环境搭建]]></title>
    <url>%2F2018%2F03%2F27%2Frap1%2F</url>
    <content type="text"><![CDATA[前后端分离的路上，一款强大的API管理工具，可以降低沟通成本，大大提高开发效率，节省的时间，我们来做更有意义的事情。 API管理工具又很多，选择适合自身需求的就是最好 这里以阿里妈妈出品的RAP产品；目前RAP分为： RAP1，RAP2 虽然RAP1不再添加新功能，只做维护工作，介于RAP2目前还不是很成熟，本篇文章先讲RAP1的搭建过程(虽然官方Wiki已经有很详细的部署教程，但在部署过程中还是遇到一些问题，因此就记录下来) 如果你不需要搭建，可以直接访问RAP1提供的服务http://rapapi.org 项目构建 安装环境：Windows 10 x64 准备工具：Git，IDEA，JDK1.8+，Tomcat8*，MySQL，Redis3+ 这里Git，IDEA，JDK1.8，Tomcat8*，MySQL不再赘述安装步骤以及环境配置 安装基本工具Redis由于Redis 官方并未支持Windows系统，因此借助MicrosoftArchive团队所提供的Windows Redis安装包，这里下载最新的Redis-x64-3.2.100.msi 以管理员身份运行安装包Redis-x64-3.2.100.msi 添加环境变量 默认6379端口 检查Redis服务，是否已经启动 其他默认即可，不要设置Memory Limit 构建项目获取源代码12git clone git@github.com:thx/RAP.gitgit checkout release 确保您正确的切换到release分支，否则会出现少包，因为master分支引用一些不对外公开的内部组件，不提供给外部用户使用 导入到IDEAIDEA==&gt;Open==&gt;RAP 初始化数据库执行脚本文件：RAP\src\main\resources\database\initialize.sql 修改配置文件文件：RAP\src\main\resources\database\config.properties修改：数据库用户名及密码 启动项目 Edit config Create Tomcat Deploy war Deploy success 注意成功部署后，请注册新账号登录 至此，RAP1的本机部署已经完成。 其他 RAP1学习中心 部分同学无法查看视频，请异步至issues RAP1 Wiki文档 Mockjs RAP2环境搭建教程]]></content>
      <categories>
        <category>Api</category>
      </categories>
      <tags>
        <tag>RAP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo Blog 搭建]]></title>
    <url>%2F2018%2F03%2F25%2Fhexo-blog%2F</url>
    <content type="text"><![CDATA[之前一直纠结用Jekyll还是Hexo来搭建GitHub Page博客，原本一直想搭建一个Material Design主题风格，从Hexo Themes中寻找到一款不错的主题，indigo是一款支持IE10+，评论，目录导航，分享等功能的轻量Blog主题。 简单的修改了该主题之后，本地预览都没有什么问题，但是部署到Github上，样式什么的都无法加载，应该是我的操作姿势不对吧，调整了半天没有解决，烦躁中找到之前star的另一款很受欢迎的Next主题。 既然自己修改的无法正常部署预览，那就用别人写好的吧，刚好赶上Next新版本V6.0系列的推出，那就不废话，直接开干 材料准备 Node LTS Git Hexo Next 安装Node,Git的安装过程略 Hexo Hexo 安装 1$ npm install hexo-cli -g 初始化 1$ hexo init &lt;your blog name&gt; 安装依赖包 12$ cd &lt;you blog name&gt;$ npm install 启动服务预览 1$ hexo serve Next 安装Next 主题 1$ git clone https://github.com/theme-next/hexo-theme-next themes/next 当前操作在 blog的根目录下执行 修改Blog 配置you blog name 根目录 _config.yml theme: 由原来默认landscape更改位next(大约：76行) 其他配置项，根据自己的需求进行更改，我这里更改了title,subtitle,author,language,url配置，其中language如果没有修改，默认为英文语言，在V6.0系列由原来zh-Hans更新为zh-CN 添加部署到Github配置1234deploy: type: git repo: https://github.com/BladeCode/BladeCode.github.io.git # 用户名仓库 branch: master # 用户名仓库的分支应该指定master，master分支也可以不用写 修改Theme 配置路径：you blog name/Themes/next/_config.yml这里不罗嗦了，其配置可参考hexo-theme-next项目README文件 部署上面已经配置好了部署的目标仓库，那么这里直接使用Hexo提供的部署命令即可1$ hexo d 相关命令介绍等，请查看官方文档说明 部署完成后，可以直接访问 http://you blog name/github.io 自定义域名虽然现在blog可以使用Githug提供的项目二级域名来访问，为了个性化以及方便等，配置自己的域名 登录域名所属的管理网站(这里以阿里云域名服务为例) 添加解析 1234567891011121314151617$ # 解析一记录类型：CNAME主机记录：www记录值：bladecode.github.io解析路线：default$ # 解析二记录类型：A主机记录：@记录值：192.30.252.153解析路线：default$ # 解析三记录类型：A主机记录：@记录值：192.30.252.154解析路线：default 192.30.252.153是GitHub的地址，你也可以ping你的 http://xxxx.github.io 的ip地址，填入进去 修改Github上项目的domain设置 添加CNAME文件保存路径：you blog name/source新增文件：CNAME 文件 (格式要求:保存成所有文件而不是txt文件)CNAME 文件内容：incoder.org 如果带有www，那么以后访问的时候必须带有www完整的域名才可以访问，但如果不带有www，以后访问的时候带不带www都可以访问。所以建议，不要带有www Https开启开启Https 需要借助Cloudflare，关于Cloudflare的介绍等不在这里展开 注册账号 Add website Querying your DNS Select Plan 域名解析记录获取 DNS 对比，并修改Cloudflare提供的DNS来解析 域名管理后台，修改DNS 阿里云服务相关域名DNS修改帮助文档 成功激活 SSL证书申请提醒 添加强制HTTPS规则 规则制定 好了剩下的就是等证书颁发，可能要等上一些时间，具体每个人不尽相同，这里就不多做解释了。 Let’s all，本次的Hexo的相关初级教程就到这里]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Build</tag>
      </tags>
  </entry>
</search>
